# NOTE: This code is generated by Claude Opus 4.5
import ast
from typing import Dict, List, Optional, Set

from ....domain.ports import FrameworkCallExtractor
from ....domain.values import FnName, SourceCode


class JaxCallVisitor(ast.NodeVisitor):
    """AST visitor that extracts JAX function calls from source code."""

    # Known JAX-related module names and common aliases
    JAX_MODULES: Set[str] = {"jax", "flax", "optax", "haiku"}
    JAX_ALIASES: Dict[str, str] = {
        "jnp": "jax.numpy",
        "lax": "jax.lax",
        "hk": "haiku",
        "nn": "flax.linen",
    }

    def __init__(self) -> None:
        self.calls: List[str] = []
        self.imports: Dict[str, str] = {}  # alias -> full module path
        self.from_imports: Dict[str, str] = {}  # name -> full module.name

    def visit_Import(self, node: ast.Import) -> None:
        """Track `import jax` and `import jax.numpy as jnp` style imports."""
        for alias in node.names:
            module_name = alias.name
            as_name = alias.asname or alias.name

            # Track if it's a JAX-related import
            root_module = module_name.split(".")[0]
            if root_module in self.JAX_MODULES:
                self.imports[as_name] = module_name

        self.generic_visit(node)

    def visit_ImportFrom(self, node: ast.ImportFrom) -> None:
        """Track `from jax import vmap` and `from jax.numpy import dot` style imports."""
        if node.module is None:
            self.generic_visit(node)
            return

        root_module = node.module.split(".")[0]
        if root_module in self.JAX_MODULES:
            for alias in node.names:
                name = alias.name
                as_name = alias.asname or name
                full_path = f"{node.module}.{name}"
                self.from_imports[as_name] = full_path

        self.generic_visit(node)

    def visit_Call(self, node: ast.Call) -> None:
        """Extract JAX function calls like jax.vmap(), jnp.dot(), vmap()."""
        call_name = self._get_call_name(node.func)
        if call_name:
            resolved = self._resolve_to_jax(call_name)
            if resolved:
                self.calls.append(resolved)

        self.generic_visit(node)

    def _get_call_name(self, node: ast.expr) -> Optional[str]:
        """Extract the full call name from a Call node's func attribute."""
        if isinstance(node, ast.Name):
            # Direct call: vmap(fn)
            return node.id
        elif isinstance(node, ast.Attribute):
            # Attribute call: jax.vmap(fn) or obj.method()
            parts: List[str] = [node.attr]
            current = node.value
            while isinstance(current, ast.Attribute):
                parts.append(current.attr)
                current = current.value
            if isinstance(current, ast.Name):
                parts.append(current.id)
            parts.reverse()
            return ".".join(parts)
        return None

    def _resolve_to_jax(self, call_name: str) -> Optional[str]:
        """Resolve a call name to its full JAX path if it's a JAX function."""
        parts = call_name.split(".")
        root = parts[0]

        # Check if it's a direct JAX module call (jax.vmap, jax.numpy.dot)
        if root in self.JAX_MODULES:
            return call_name

        # Check if it's an aliased import (jnp.dot -> jax.numpy.dot)
        if root in self.imports:
            full_module = self.imports[root]
            return (
                full_module + "." + ".".join(parts[1:])
                if len(parts) > 1
                else full_module
            )

        # Check known aliases (jnp -> jax.numpy)
        if root in self.JAX_ALIASES:
            full_module = self.JAX_ALIASES[root]
            return (
                full_module + "." + ".".join(parts[1:])
                if len(parts) > 1
                else full_module
            )

        # Check if it's a from-import (vmap -> jax.vmap)
        if call_name in self.from_imports:
            return self.from_imports[call_name]

        return None


class JaxCallExtractor(FrameworkCallExtractor):
    """Extracts JAX-specific function calls from source code.

    Implements the domain FrameworkCallExtractor protocol for JAX.
    """

    def extract_calls(self, code: SourceCode) -> Set[FnName]:
        """Extract JAX function calls from source code using AST parsing."""
        called_jax_functions: Set[FnName] = set()

        try:
            tree = ast.parse(code)
        except SyntaxError:
            return set()

        visitor = JaxCallVisitor()
        visitor.visit(tree)

        for call in visitor.calls:
            called_jax_functions.add(FnName(call))

        return called_jax_functions
